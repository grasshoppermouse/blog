{
  "hash": "5e5a29ee75f9583f9054326350e7afb7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Create a webpage listing all your twitter threads\"\nauthor: \"Ed Hagen\"\ndate: \"2025-05-18\"\nimage: tweets.js.png\ndescription: \"Notes on how to import your tweets into R and create webpage listing all your threads\"\ndraft: false\n---\n\n\n\nIf you've put a lot of effort into your twitter threads over the years, it would be nice to have a webpage that links to each one. Here are my notes on how to do it using `R` and `rmarkdown` or [Quarto](https://quarto.org). These notes will get you started but they're not a complete recipe -- you will have to fill in some details on your own.\n\nFirst, request an archive of your data from your [account settings page](https://x.com/settings/account) on twitter (now **X**):\n\n![](settings.png)\n\nTwitter might take a couple of days to generate this for you. The archive comes with a nifty web interface (which you won't be using here).\n\nSecond, your tweets are in the  `tweets.js` file inside the `data` directory inside the archive directory (`twitter-2025-xx-yy-zzzzz/data/tweets.js`). Open this large `json` file in your favorite text editor, delete the part I highlighted in blue here, and save this in a new file (e.g., `tweets-copy.js`):\n\n![](tweets.js.png)\n\nThird, import this `json` file into `R`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(jsonlite)\n\n# Set these to your values\nscreen_name <- \"ed_hagen\"\narchive_path <- \"~/Documents/Misc/twitterstuff/twitterarchive/twitter-2024-09-01-b826014a3be886e00b25dd88cf610708cc6b326d0209ebe75a377564d8fe740a/data/tweets-copy.js\"\n\nd0 <- fromJSON(archive_path)\n\ntweets <- \n  # tweet data frame: each row is one tweet\n  d0$tweet |> \n  # convert twitter dates to R dates to sort on date\n  mutate(created_at2 = parse_date_time(created_at, orders = \"%a %b %d %H:%M:%S %z %Y\")) |> \n  arrange(created_at2)\n\n# This is a complex data frame\n# Some columns are lists, or lists of data frames\nglimpse(tweets)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 5,543\nColumns: 22\n$ edit_info                 <df[,1]> <data.frame[26 x 1]>\n$ retweeted                 <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,…\n$ source                    <chr> \"<a href=\\\"http://twitter.com\\\" rel=\\\"nofoll…\n$ entities                  <df[,5]> <data.frame[26 x 5]>\n$ display_text_range        <list> <\"0\", \"315\">, <\"0\", \"111\">, <\"0\", \"20\">, <\"0…\n$ favorite_count            <chr> \"2\", \"81\", \"3\", \"58\", \"3\", \"1\", \"0\", \"1\",…\n$ in_reply_to_status_id_str <chr> \"1074700457082261504\", NA, \"113707085695640…\n$ id_str                    <chr> \"1075115946581213184\", \"1137070856956403712\"…\n$ in_reply_to_user_id       <chr> \"707433649\", NA, \"1021809792082358272\", NA, …\n$ truncated                 <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ retweet_count             <chr> \"1\", \"26\", \"0\", \"13\", \"0\", \"0\", \"0\", \"0\", \"0…\n$ id                        <chr> \"1075115946581213184\", \"1137070856956403712\"…\n$ in_reply_to_status_id     <chr> \"1074700457082261504\", NA, \"1137070856956403…\n$ created_at                <chr> \"Tue Dec 18 19:49:51 +0000 2018\", \"Fri Jun 0…\n$ favorited                 <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA…\n$ full_text                 <chr> \"@nicholaraihani @NatureHumBehav @vaughanbel…\n$ lang                      <chr> \"en\", \"en\", \"in\", \"en\", \"en\", \"en\", \"en\", \"e…\n$ in_reply_to_screen_name   <chr> \"nicholaraihani\", NA, \"ed_hagen\", NA, \"samue…\n$ in_reply_to_user_id_str   <chr> \"707433649\", NA, \"1021809792082358272\", NA, …\n$ possibly_sensitive        <lgl> FALSE, FALSE, NA, FALSE, FALSE, FALSE, NA, F…\n$ extended_entities         <df[,1]> <data.frame[26 x 1]>\n$ created_at2               <dttm> 2018-12-18 19:49:51, 2019-06-07 18:56:32, 20…\n```\n\n\n:::\n:::\n\n\n\nFourth, many of my 5543 tweets are replies to other users, whereas the tweets I want for this project are my top level tweets along with my replies to my top level tweets (i.e., my threads). Top level tweets are identified by an `NA` in the `in_reply_to_status_id` column of the `tweets` data frame:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_level <- is.na(tweets$in_reply_to_status_id)\ntable(top_level)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntop_level\nFALSE  TRUE \n 4947   596 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a list where each element is a single-row\n# data frame for each top-level tweet. In the next chunk\n# we will append the associated reply tweets to these\n# data frames as additional rows, i.e., each data frame \n# will be one thread.\nposts <- \n  tweets[top_level,] |> \n  split(tweets$id[top_level])\n\n# Get the replies to self (substitute your screen name)\nreplies <- \n  tweets |> \n  dplyr::filter(in_reply_to_screen_name == screen_name)\n```\n:::\n\n\n\nFifth, we need to link your replies to yourself to the proper top-level tweets, and in the proper order. This is how I did it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add rows to each data frame, where each row\n# is one tweet in the thread, in chronological order.\n# The first row is your original post, and the remaining\n# rows are your replies\nfor (i in 1:length(posts)){\n  while (T){\n    id <- last(posts[[i]]$id)\n    rs <- which(replies$in_reply_to_status_id == id)\n    if (length(rs) == 0) break\n    posts[[i]] <- bind_rows(posts[[i]], replies[rs,])\n  }\n}\n```\n:::\n\n\n\nAt this point you could do a number of things, such as rendering each thread yourself. The full text of each tweet is in the `full_text` column. Each tweet also has an `entities` data frame with hash tags, media urls (which are also in your archive), and mentions. Retweets are identified with an \"RT\" at the beginning of the full text.\n\nHere I'm instead going to filter on threads, which I'll define as tweets with one or more replies by me:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of tweets in each thread\nnum_tweets <- map_int(posts, nrow)\n\n# Number of threads, i.e., two or more tweets\nsum(num_tweets>1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 101\n```\n\n\n:::\n\n```{.r .cell-code}\nthreads <- posts[num_tweets>1]\n```\n:::\n\n\n\nThe easiest way to render your threads is to embed them in webpage using the following html that includes your screen name and top-level tweet `id`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the ids of the first tweet in each thread\nids <- map_chr(threads, \\(x) x$id[1])\n\nhtml <- \n'\n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/{screen_name}/status/{ids}\"></a>\n</blockquote> \n'\n\n# Create a vector of html blockquotes\n# that reference each top level tweet\nout <- str_glue(html)\nout[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/ed_hagen/status/1137070856956403712\"></a>\n</blockquote> \n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/ed_hagen/status/1144716520825577472\"></a>\n</blockquote> \n```\n\n\n:::\n\n```{.r .cell-code}\n# You will need to append this at\n# the end of all the blockquote tags\ntwitter_script <- '<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>'\n```\n:::\n\n\n\nAt this point, you could write `out` to a file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This isn't a complete html file\nwrite_lines(c(out, twitter_script), file = \"myhtmlfragment.html\")\n```\n:::\n\n\n\nTo instead render it within an `rmarkdown` or `quarto` file, set chunk options `output: asis` and `echo: false`:\n\n```{{r}}\n#| output: asis\n#| echo: false\n\n# Render the threads, plus the\n# necessary script from twitter\nout\ncat(twitter_script)\n```\n\nHere are the first three of my threads:\n\n\n\n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/ed_hagen/status/1137070856956403712\"></a>\n</blockquote> \n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/ed_hagen/status/1144716520825577472\"></a>\n</blockquote> \n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/ed_hagen/status/1172176705798070273\"></a>\n</blockquote> \n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n\n\nHere is most of the code in one place:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(jsonlite)\n\n# Set these to your values\nscreen_name <- \"my_screen_name\"\narchive_path <- \"path/to/my/twitter-2025-archive-xx-yy-zz/data/tweets-copy.js\"\n\nd0 <- fromJSON(archive_path)\n\ntweets <- \n  d0$tweet |> \n  mutate(created_at2 = parse_date_time(created_at, orders = \"%a %b %d %H:%M:%S %z %Y\")) |> \n  arrange(created_at2)\n\ntop_level <- is.na(tweets$in_reply_to_status_id)\n\nposts <- \n  tweets[top_level,] |> \n  split(tweets$id[top_level])\n\nreplies <- \n  tweets |> \n  dplyr::filter(in_reply_to_screen_name == screen_name)\n\nfor (i in 1:length(posts)){\n  while (T){\n    id <- last(posts[[i]]$id)\n    rs <- which(replies$in_reply_to_status_id == id)\n    if (length(rs) == 0) break\n    posts[[i]] <- bind_rows(posts[[i]], replies[rs,])\n  }\n}\n\nnum_tweets <- map_int(posts, nrow)\nthreads <- posts[num_tweets>1]\n\nids <- map_chr(threads, \\(x) x$id[1])\n\nhtml <- \n'\n<blockquote class=\"twitter-tweet\">\n  <a href=\"https://twitter.com/{screen_name}/status/{ids}\"></a>\n</blockquote> \n'\n\nout <- str_glue(html)\n\ntwitter_script <- '<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>'\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}